<html lang="en">
	<head>
		<title>Yuka | First-Person Controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin:0;
				overflow:hidden;
			}
			#intro {
				position: fixed;
				height: 100%;
				width: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
				background-color: rgba(0,0,0,0.5);
				color: #ffffff;
				font-family: Arial, Helvetica, sans-serif;
				font-size: 40;
			}
			#intro.hidden {
				display: none;
			}
		</style>
	</head>
<body>

	<section id="intro">
		Click to Play
	</section>

	<script type="module">

	import * as YUKA from '../../../build/yuka.module.js';
	import * as THREE from '../../lib/three.module.js';
	import { GLTFLoader } from '../../lib/GLTFLoader.module.js';

	import { Player } from './src/Player.js';
	import { createConvexRegionHelper } from '../../graph/common/js/NavMeshHelper.js';

	let camera, scene, renderer;

	let entityManager, time, player;

	init();

	//

	function init() {

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );
			camera.matrixAutoUpdate = false;

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xa0a0a0 );
			scene.fog = new THREE.Fog( 0xa0a0a0, 20, 40 );

			//

			const geometry = new THREE.PlaneBufferGeometry( 150, 150 );
			const material = new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } );

			const ground = new THREE.Mesh( geometry, material );
			ground.rotation.x = - Math.PI / 2;
			ground.matrixAutoUpdate = false;
			ground.updateMatrix();
			scene.add( ground );

			//

			const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.6 );
			hemiLight.position.set( 0, 100, 0 );
			scene.add( hemiLight );

			const dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
			dirLight.position.set( 0, 20, 10 );
			scene.add( dirLight );

			//

			const audioLoader = new THREE.AudioLoader();
			const listener = new THREE.AudioListener();
			camera.add( listener );

			const step1 = new THREE.Audio( listener );
			const step2 = new THREE.Audio( listener );

			audioLoader.load( 'audio/step1.ogg', ( buffer ) => { step1.setBuffer( buffer ) } );
			audioLoader.load( 'audio/step2.ogg', ( buffer ) => { step2.setBuffer( buffer ) } );

			//

			const glTFLoader = new GLTFLoader();
			glTFLoader.load( 'model/house.glb', ( gltf ) => {

				// add object to scene

				scene.add( gltf.scene );

				gltf.scene.traverse( ( object ) => {

					object.matrixAutoUpdate = false;
					object.updateMatrix();

					if ( object.isMesh ) {

						for ( const material of object.material ) {

							if ( material.transparent === true ) material.depthWrite = false;

						}

					}

				} );

				// load respective navmesh

				const loader = new YUKA.NavMeshLoader();

				loader.load( './navmesh/navmesh.glb', { epsilonCoplanarTest: 0.25 } ).then( ( navMesh ) => {

					// visualize convex regions

					const navMeshGroup = createConvexRegionHelper( navMesh );
					//scene.add( navMeshGroup );

					player.navMesh = navMesh;

					animate();

				} );

			} );

			//

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.gammaOutput = true;
			document.body.appendChild( renderer.domElement );

			window.addEventListener( 'resize', onWindowResize, false );

			const intro = document.getElementById( 'intro' );

			intro.addEventListener( 'click', function ( event ) {

				player.connect();

			}, false );

			// game setup

			entityManager = new YUKA.EntityManager();
			time = new YUKA.Time();

			player = new Player();
			player.position.set( - 13, - 0.75, - 9 );
			player.setRotation( - 2.2, 0.2 );
			player.lookSpeed = 2;
			player.height = 2;
			player.maxSpeed = 40;

			player.onActive = () => { intro.classList.add( 'hidden' ) };
			player.onInactive = () => { intro.classList.remove( 'hidden' ) };
			player.onAudio = ( id ) => {

				if ( id === 'rightStep' ) step1.play();
				if ( id === 'leftStep' ) step2.play();

			};

			entityManager.add( player );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			const delta = time.update().getDelta();

			entityManager.update( delta );

			camera.matrixWorld.copy( player.head.worldMatrix );

			renderer.render( scene, camera );

		}

	</script>

</body>
</html>
